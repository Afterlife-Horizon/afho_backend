#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_NODES 100
#define INF 999999999

// noeud du graphe
typedef struct Node {
    int index; // index du noeud
    int heuristic; // heuristique du noeud
    int cost; // coût pour arriver au noeud
} Node;

// graphe
typedef struct Graph {
    Node nodes[MAX_NODES]; // tableau de noeuds
    int adj_matrix[MAX_NODES][MAX_NODES]; // matrice d'adjacence
    int n_nodes; // nombre de noeuds
} Graph;

// initialisation d'un graphe
void init_graph(Graph* graph) {
    graph->n_nodes = 0;
    for (int i = 0; i < MAX_NODES; i++) {
        for (int j = 0; j < MAX_NODES; j++) {
            graph->adj_matrix[i][j] = INF;
        }
    }
}

// ajouter un noeud dans un graphe
void add_node(Graph* graph, int index, int heuristic) {
    graph->nodes[graph->n_nodes].index = index;
    graph->nodes[graph->n_nodes].heuristic = heuristic;
    graph->nodes[graph->n_nodes].cost = INF;
    graph->n_nodes++;
}

// ajouter une arête dans un graphe
void add_edge(Graph* graph, int i, int j, int weight) {
    graph->adj_matrix[i][j] = weight;
}

// trouver le noeud avec le coût le plus faible parmi un ensemble de noeuds
Node* get_lowest_cost_node(Node** nodes, int n_nodes) {
    Node* lowest_cost_node = NULL;
    int min_cost = INF;
    for (int i = 0; i < n_nodes; i++) {
        if (nodes[i]->cost < min_cost) {
            min_cost = nodes[i]->cost;
            lowest_cost_node = nodes[i];
        }
    }
    return lowest_cost_node;
}

// calculer le coût pour arriver à un noeud
int get_cost(Graph* graph, int i, int j) {
    return graph->adj_matrix[i][j];
}

// copier un tableau de noeuds
Node** copy_nodes(Node** nodes, int n_nodes) {
    Node** new_nodes = malloc(n_nodes * sizeof(Node*));
    for (int i = 0; i < n_nodes; i++) {
        new_nodes[i] = malloc(sizeof(Node));
        memcpy(new_nodes[i], nodes[i], sizeof(Node));
    }
    return new_nodes;
}

// libérer un tableau de noeuds
void free_nodes(Node** nodes, int n_nodes) {
    for (int i = 0; i < n_nodes; i++) {
        free(nodes[i]);
    }
    free(nodes);
}

// trouver le chemin le plus court entre les noeuds start_index et end_index dans le graphe
int a_star(Graph* graph, int start_index, int end_index, int* path) {
    // initialisation
    for (int i = 0; i < graph->n_nodes; i++) {
        if (graph->nodes[i].index == start_index) {
            graph->nodes[i].cost = 0;
            break;
        }
    }
    // algorithme A*
    bool found_path = false;
    while (!found_path) {
        bool all_visited = true;
        for (int i = 0; i < graph->n_nodes; i++) {
            if (graph->nodes[i].cost < INF) {
                all_visited = false;
                break;
            }
        }
        if (all_visited) {
            break; // tous les noeuds ont été visités, sortie
        }
        Node** open_nodes = malloc(graph->n_nodes * sizeof(Node*));
        int n_open_nodes = 0;
        Node** closed_nodes = malloc(graph->n_nodes * sizeof(Node*));
        int n_closed_nodes = 0;
        for (int i = 0; i < graph->n_nodes; i++) {
            if (graph->nodes[i].cost < INF && !path_contains(path, graph->nodes[i].index)) {
                open_nodes[n_open_nodes] = &graph->nodes[i];
                n_open_nodes++;
            } else if (graph->nodes[i].cost < INF && path_contains(path, graph->nodes[i].index)) {
                closed_nodes[n_closed_nodes] = &graph->nodes[i];
                n_closed_nodes++;
            }
        }
        Node* current_node = get_lowest_cost_node(open_nodes, n_open_nodes);
        if (current_node == NULL) {
            break; // aucun chemin possible, sortie
        }
        if (current_node->index == end_index) {
            found_path = true; // chemin trouvé, sortie
            continue;
        }
        for (int i = 0; i < graph->n_nodes; i++) {
            if (get_cost(graph, current_node->index, i) < INF) {
                int new_cost = current_node->cost + get_cost(graph, current_node->index, i);
                int new_heuristic = new_cost + graph->nodes[i].heuristic;
                Node** new_path = copy_nodes(path, MAX_NODES);
                new_path[path_length(path)] = current_node;
                graph->nodes[i].cost = new_cost;
                graph->nodes[i].heuristic = new_heuristic;
                free_nodes(path, MAX_NODES);
                path = new_path;
            }
        }
        free_nodes(open_nodes, graph->n_nodes);
        free_nodes(closed_nodes, graph->n_nodes);
    }
    // construction du chemin
    if (found_path) {
        int n_steps = 0;
        Node* current_node = &graph->nodes[end_index];
        while (current_node != NULL) {
            path[n_steps] = current_node->index;
            n_steps++;
            current_node = get_lowest_cost_node(&graph->nodes, graph->n_nodes);
        }
        reverse_path(path, n_steps);
        return n_steps;
    } else {
        return -1;
    }
}

// Fonction auxiliaire pour afficher le chemin
void print_path(int* path, int n_steps) {
    printf("Path: ");
    for (int i = 0; i < n_steps; i++) {
        printf("%d ", path[i]);
    }
    printf("
");
}

int main() {
    // création du graphe
    Graph graph;
    init_graph(&graph);
    add_node(&graph, 0, 10);
    add_node(&graph, 1, 5);
    add_node(&graph, 2, 7);
    add_node(&graph, 3, 8);
    add_edge(&graph, 0, 1, 2);
    add_edge(&graph, 0, 2, 3);
    add_edge(&graph, 1, 2, 1);
    add_edge(&graph, 2, 3, 4);

    // recherche du chemin le plus court
    int path[MAX_NODES];
    memset(path, -1, MAX_NODES * sizeof(int));
    int n_steps = a_star(&graph, 0, 3, path);
    if (n_steps != -1) {
        print_path(path, n_steps);
    } else {
        printf("No path found!
");
    }

    return 0;
}
 